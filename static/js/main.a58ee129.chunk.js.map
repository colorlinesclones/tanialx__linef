{"version":3,"sources":["item.js","square.js","board.js","score.js","index.js"],"names":["Item","height","this","props","y","width","x","cx","cy","r","stroke","strokeWidth","fill","color","React","Component","Square","nextProps","isActivated","item","type","itemOrBlank","style","className","onClick","Board","colors","numberOfPreRenderedItemAtEachMove","state","squares","initArray","selected","arr","Array","w","h","noRandomF","freeSquareIdxArr","randomFreeSquareIndex","i","pop","Math","floor","random","length","indexes","sq","push","no_of_random","excludes","free_square_index_arr","fs","reduce","acc","curr","index","includes","fs_idx","splice","setState","random_free_square_index","idx_of_f_items","fItems","active_idx_arr","slice","switch_to_idx","indexOf","forEach","idx","resolved_idx","checkResolved","ri","score_incr","curr_squares","resolved","parseInt","base_type","base_color","line_wrap_start","line_wrap_end","countForward","incr","countBackward","decr","concat","onSquareClicked","content","renderSquare","renderRows","Score","score","Game","increaseScore","bind","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a58ee129.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Item extends React.Component {\n\n    render() {\n        return (\n            <svg height={this.props.y * 2} width={this.props.x * 2}>\n                <circle cx={this.props.x} cy={this.props.y} r={this.props.r} stroke=\"#555555\" strokeWidth=\"1\" fill={this.props.color} />\n            </svg>\n        );\n    }\n}","import React from 'react';\nimport Item from './item';\n\nexport default class Square extends React.Component {\n\n    shouldComponentUpdate(nextProps) {\n\t\t/** Status */\n        if (this.props.isActivated !== nextProps.isActivated) {\n            return true\n        }\n\t\t/** Item */\n        // blank -> blank (no change)\n        if (this.props.item === null && nextProps.item === null) return false\n        // item -> item: compare all sub-properties (type and color) to see if it's the same item\n        if (this.props.item !== null && nextProps.item !== null) {\n            return this.props.item.type !== nextProps.item.type || this.props.item.color !== nextProps.item.color\n        }\n        // item -> blank or blank -> item\n        return true\n    }\n\n    render() {\n        let itemOrBlank\n        if (this.props.item != null) {\n            itemOrBlank = <Item x='22' y='22'\n                color={this.props.item.color}\n                r={this.props.item.type === 'p' ? 15 : 5} />\n        }\n        const style = this.props.isActivated ? 'square square-active' : 'square'\n        return (\n            <div className={style}\n                onClick={() => this.props.onClick()}>\n                {itemOrBlank}\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport './index.css';\nimport Square from './square.js';\n\nexport default class Board extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.colors = ['#FF9494', '#FFD08B', '#E2E68C', '#A8F0D4', '#9DE2FE', '#C5B8F0', '#FBD8FF']\n        this.numberOfPreRenderedItemAtEachMove = 3\n        this.state = {\n            squares: this.initArray(),\n            selected: null\n        };\n    }\n\n    initArray() {\n        let arr = Array(this.props.w * this.props.h).fill(null)\n        const noRandomP = 5;\n        const noRandomF = this.numberOfPreRenderedItemAtEachMove;\n        let freeSquareIdxArr = this.randomFreeSquareIndex(noRandomP + noRandomF, arr, [])\n        for (let i = 0; i < noRandomP; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'p',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        } for (let i = 0; i < noRandomF; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'f',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        }\n        return arr\n    }\n\n    fItems() {\n        var indexes = [], i;\n        const sq = this.state.squares;\n        for (i = 0; i < sq.length; i++) {\n            if (sq[i] && sq[i].type === 'f') {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n\n    randomFreeSquareIndex(no_of_random, squares, excludes) {\n        let free_square_index_arr = []\n\n        /**\n         * An array contains all blank square's index (no item)\n         * We will generate random positions to render related items based on this array\n         * so that all items are rendered in their own separate square\n         */\n        let fs = squares.reduce((acc, curr, index) => {\n            if (curr === null && !excludes.includes(index)) {\n                acc.push(index);\n            }\n            return acc;\n        }, []);\n\n        for (let i = 0; i < no_of_random; i++) {\n\n            // 1. Pick a random index fs_idx of free squares ('fs')\n            // 2. fs[fs_idx] = corresponding index of 'squares' where there's no item occupied (value to return)\n            // 3. Remove element at index free_sqr_idx from free_squares (since it's no longer free)\n\n            const fs_idx = Math.floor(Math.random() * fs.length)\n            free_square_index_arr.push(fs.splice(fs_idx, 1)[0])\n        }\n        return free_square_index_arr\n    }\n\n    onSquareClicked(i) {\n        if (this.state.squares[i] !== null && this.state.squares[i].type === 'p') {\n            // Detect attempt to move item from this square to another square        \n            this.setState({ selected: i })\n        } else if (this.state.selected != null) {\n\n            let random_free_square_index = null\n            let idx_of_f_items = this.fItems()\n\n            /*\n             * Save index of all actively changed square in 'active_idx_arr' variable\n             * so that we can check if any set of items is resolved later on\n             * (match-5)\n             * Only save those contain 'p' items as 'f' items should not result in any match-5\n             */\n            let active_idx_arr = [i]\n\n            const squares = this.state.squares.slice();\n\n            /** \n             * A blank square has just been selected as a move-to destination\n             * Remove item from previous square saved in 'selected' state\n             * Add item to newly selected square\n             * Refresh board's state so that related items are re-rendered\n             */\n\n            // Resolve 'f' items\n            if (squares[i] && squares[i].type === 'f') {\n                /**\n                 * This square is occupied by existing item due to user's move\n                 * before future item can acquire it\n                 * Render future item at another random square as 'p' (present) item\n                 */\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove + 1, squares, [i, this.state.selected])\n                const switch_to_idx = random_free_square_index.pop()\n                squares[switch_to_idx] = {\n                    type: 'p',\n                    color: squares[i].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(switch_to_idx)\n\n                // remove this index from 'idx_of_f_items' array\n                idx_of_f_items.splice(idx_of_f_items.indexOf(i), 1)\n            } else {\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove, squares, [i, this.state.selected])\n            }\n            /** For all other f-items with no conflict, render full-size */\n            idx_of_f_items.forEach(idx => {\n                squares[idx] = {\n                    type: 'p',\n                    color: squares[idx].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(idx)\n            })\n\n            // Create new 'f' (future) items (small items) at some random positions\n            for (let i = 0; i < this.numberOfPreRenderedItemAtEachMove; i++) {\n                squares[random_free_square_index.pop()] = {\n                    type: 'f',\n                    color: this.colors[Math.floor(Math.random() * this.colors.length)]\n                }\n            }\n            squares[i] = {\n                type: squares[this.state.selected].type,\n                color: squares[this.state.selected].color\n            }\n            squares[this.state.selected] = null\n            const resolved_idx = this.checkResolved(squares, active_idx_arr)\n            for (const ri of resolved_idx) {\n                squares[ri] = null\n            }\n            this.setState({ squares: squares, selected: null })\n            // Update score\n            if (resolved_idx.length > 0) {\n                this.props.score_incr(resolved_idx.length)\n            }\n        } else {\n            // A blank square has just been selected but no revious item selection \n            // recorded in board's state\n            // Ignore this click event\n            this.setState({ selected: null })\n        }\n    }\n\n    checkResolved(curr_squares, active_idx_arr) {\n        let resolved = []\n        const w = parseInt(this.props.w)\n        const h = parseInt(this.props.h)\n\n        active_idx_arr.forEach(i => {\n\n            const base_type = curr_squares[i].type\n            const base_color = curr_squares[i].color\n\n            /**\n             * Check horizontal line [ i % w == 0 ] [ i % w == 1 ] ... [ i % w == w-1 ]\n             */\n            {\n                const line_wrap_start = Math.floor(i / h) * w\n                const line_wrap_end = line_wrap_start + w\n                // count forward\n                let countForward = []\n                for (let incr = i + 1; incr < line_wrap_end && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr++) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - 1; decr >= line_wrap_start && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr--) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n            /**\n             * Check vertical line\n             * [ i - w]\n             * [ i ]\n             * [ i + w]\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += w) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= w) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n             * Check diagonal line \n             * DIRECTION: \\\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w + 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w + 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w - 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w + 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n            * Check diagonal line \n            * DIRECTION: /\n            */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w - 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w - 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w + 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w - 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n        })\n        return resolved\n    }\n\n    renderSquare(idx) {\n        return <Square key={idx}\n            item={this.state.squares[idx]}\n            onClick={() => this.onSquareClicked(idx)}\n            isActivated={this.state.selected === idx} />;\n    }\n\n    renderRows() {\n        let content = [];\n        for (let i = 0; i < this.state.squares.length; i++) {\n            content.push(this.renderSquare(i));\n        }\n        return content\n    }\n\n    render() {\n        return (\n            <div className='game-board'>\n                {this.renderRows()}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\nexport default class Score extends React.Component {\n\n    render() {\n        return (\n            <span>{this.props.score}</span>\n        )\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from './board.js'\nimport Score from './score';\n\nclass Game extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            score: 0\n        }\n        this.increaseScore = this.increaseScore.bind(this)\n    }\n\n    increaseScore(incr) {\n        this.setState({ score: this.state.score + incr })\n    }\n\n    render() {\n        return (\n            <div className=\"game\">\n                <div>\n                    <div className=\"score-board\">\n                        <span>Score: </span>\n                        <Score score={this.state.score} />\n                    </div>\n                    <Board w='9' h='9'  score_incr={this.increaseScore} />\n                </div>\n            </div>\n        );\n    }\n}\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}