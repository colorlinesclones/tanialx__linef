{"version":3,"sources":["item.js","square.js","board.js","score.js","index.js"],"names":["Item","height","this","props","y","width","x","cx","cy","r","stroke","strokeWidth","fill","color","React","Component","Square","nextProps","isActivated","item","type","itemOrBlank","style","className","onClick","Board","w","parseInt","h","colors","numberOfPreRenderedItemAtEachMove","state","squares","initArray","selected","arr","Array","noRandomF","freeSquareIdxArr","randomFreeSquareIndex","i","pop","Math","floor","random","length","indexes","sq","push","no_of_random","excludes","free_square_index_arr","fs","reduce","acc","curr","index","includes","fs_idx","splice","idx","st","start","end","from_idx","to_idx","max_idx","indexNotOccupied","current_try_postion","try_route","valid_mvs","retry_other_route","try_next","isFound","failed_idx","exclude","previous_checkpoint","neighbors","line_wrap","lineWrapOfIndex","neighbor_movable","check_idx_u","check_idx_l","check_idx_r","check_idx_d","x_y","d_sq","p1","p2","dx","dy","x_y_of_toIdx","distance","sort","found","route","setState","movable","random_free_square_index","idx_of_f_items","fItems","active_idx_arr","slice","switch_to_idx","indexOf","forEach","resolved_idx","checkResolved","ri","score_incr","curr_squares","resolved","base_type","base_color","line_wrap_start","line_wrap_end","countForward","incr","countBackward","decr","concat","onSquareClicked","content","renderSquare","renderRows","Score","score","Game","increaseScore","bind","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.42a3e1fa.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Item extends React.Component {\n\n    render() {\n        return (\n            <svg height={this.props.y * 2} width={this.props.x * 2}>\n                <circle cx={this.props.x} cy={this.props.y} r={this.props.r} stroke=\"#555555\" strokeWidth=\"1\" fill={this.props.color} />\n            </svg>\n        );\n    }\n}","import React from 'react';\nimport Item from './item';\n\nexport default class Square extends React.Component {\n\n    shouldComponentUpdate(nextProps) {\n\t\t/** Status */\n        if (this.props.isActivated !== nextProps.isActivated) {\n            return true\n        }\n\t\t/** Item */\n        // blank -> blank (no change)\n        if (this.props.item === null && nextProps.item === null) return false\n        // item -> item: compare all sub-properties (type and color) to see if it's the same item\n        if (this.props.item !== null && nextProps.item !== null) {\n            return this.props.item.type !== nextProps.item.type || this.props.item.color !== nextProps.item.color\n        }\n        // item -> blank or blank -> item\n        return true\n    }\n\n    render() {\n        let itemOrBlank\n        if (this.props.item != null) {\n            itemOrBlank = <Item x='22' y='22'\n                color={this.props.item.color}\n                r={this.props.item.type === 'p' ? 15 : 5} />\n        }\n        const style = this.props.isActivated ? 'square square-active' : 'square'\n        return (\n            <div className={style}\n                onClick={() => this.props.onClick()}>\n                {itemOrBlank}\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport './index.css';\nimport Square from './square.js';\n\nexport default class Board extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.w = parseInt(this.props.w)\n        this.h = parseInt(this.props.h)\n        this.colors = ['#FF9494', '#FFD08B', '#E2E68C', '#A8F0D4', '#9DE2FE', '#C5B8F0', '#FBD8FF']\n        this.numberOfPreRenderedItemAtEachMove = 3\n        this.state = {\n            squares: this.initArray(),\n            selected: null\n        };\n    }\n\n    initArray() {\n        let arr = Array(this.w * this.h).fill(null)\n        const noRandomP = 5;\n        const noRandomF = this.numberOfPreRenderedItemAtEachMove;\n        let freeSquareIdxArr = this.randomFreeSquareIndex(noRandomP + noRandomF, arr, [])\n        for (let i = 0; i < noRandomP; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'p',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        } for (let i = 0; i < noRandomF; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'f',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        }\n        return arr\n    }\n\n    fItems() {\n        var indexes = [], i;\n        const sq = this.state.squares;\n        for (i = 0; i < sq.length; i++) {\n            if (sq[i] && sq[i].type === 'f') {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n\n    randomFreeSquareIndex(no_of_random, squares, excludes) {\n        let free_square_index_arr = []\n\n        /**\n         * An array contains all blank square's index (no item)\n         * We will generate random positions to render related items based on this array\n         * so that all items are rendered in their own separate square\n         */\n        let fs = squares.reduce((acc, curr, index) => {\n            if (curr === null && !excludes.includes(index)) {\n                acc.push(index);\n            }\n            return acc;\n        }, []);\n\n        for (let i = 0; i < no_of_random; i++) {\n\n            // 1. Pick a random index fs_idx of free squares ('fs')\n            // 2. fs[fs_idx] = corresponding index of 'squares' where there's no item occupied (value to return)\n            // 3. Remove element at index free_sqr_idx from free_squares (since it's no longer free)\n\n            const fs_idx = Math.floor(Math.random() * fs.length)\n            free_square_index_arr.push(fs.splice(fs_idx, 1)[0])\n        }\n        return free_square_index_arr\n    }\n\n    lineWrapOfIndex(idx) {\n        const st = Math.floor(idx / this.h) * this.w\n        return {\n            start: st,\n            end: st + this.w\n        }\n    }\n\n    /**\n     * check if there's a clear path for item to move from\n     * one square to another\n     * @param {*} from_idx current position index\n     * @param {*} to_idx destination index\n     * @returns true if a path is found; false otherwise\n     */\n    movable(from_idx, to_idx) {\n        /*\n         * at regular location, item can move to 4 neighbor squares\n         * i: index of item\n         * X: where i can move to, if its index is valid\n         * \n         * also, i-1 and i+1 should be within line boundaries as item at beginning of one row\n         * should not be able to move to the end of the previous row\n         * \n         * [   ] [i-w] [   ]\n         * [i-1] [<i>] [i+1]\n         * [   ] [i+w] [   ]\n         * \n         */\n\n        const sq = this.state.squares\n        const max_idx = sq.length\n        const w = this.w\n\n        const indexNotOccupied = idx => sq[idx] === null || sq[idx].type === 'f'\n\n        /*\n         * - try_route: current route (stack of index) we are checking\n         * - current_try_postion: current index we are chechking\n         * - valid_mvs: save all possible routes that we have not yet checked so that\n         *              we can come back later to check for another route in case the\n         *              current route fails\n         * - retry_other_route: signal that to_idx cannot be reached from the route we're currenty trying\n         * - try_next: signal that we should continue try/retry with next interations as there are\n         *             still possibilities of a clear path found\n         * - isFound: information of our result\n         * - failed_idx: keep track of failed check: there's no path to to_idx from these, so that\n         *               we don't need to same index over and over again in the next iterations\n         */\n        let current_try_postion = from_idx\n        let try_route = [from_idx]\n        let valid_mvs = {}\n        let retry_other_route = false;\n        let try_next = true\n        let isFound = false\n        let failed_idx = []\n\n        /**\n         * check if this index should be excluded from recursively checking\n         * to prevent forming a cycle\n         * either \n         * - it is in the fail-list ('failed_idx') that we already checked, or\n         * - it is included in try_route (that means we have travelled through this idx at some previous iteration)\n         * @param {*} idx index to check\n         * @returns \n         */\n        const exclude = idx => try_route.includes(idx) || failed_idx.includes(idx)\n\n        while (try_next) {\n\n            if (retry_other_route) {\n                /**\n                 * there's no way to reach to to_idx using the current route, we have to\n                 * come back to previous check-point and retry for another route\n                 */\n                // mark current position index as 'failed'\n                failed_idx.push(try_route.pop())\n\n                if (try_route.length === 0) {\n                    // all routes tried but no path found\n                    try_next = false\n                    isFound = false\n                } else {\n                    // return to a previous check-point\n                    const previous_checkpoint = try_route[try_route.length - 1]\n\n                    // retrieve all reachable neighbors of 'curr_from' that we previously store in 'valid_vms'\n                    let neighbors = valid_mvs[previous_checkpoint]\n                    if (!neighbors || neighbors.length === 0) {\n                        // all neighbors have been tried and no success\n                        retry_other_route = true\n                    } else {\n                        // Set up our new current-postion\n                        current_try_postion = neighbors.pop()\n                        try_route.push(current_try_postion)\n                        retry_other_route = false\n                    }\n                }\n            } else {\n                /*\n                 * Continue with the current route as there's no conflict yet\n                 */\n\n                // line boundaries\n                const line_wrap = this.lineWrapOfIndex(current_try_postion)\n\n                // 1. Find all squares reachable from the current position\n\n                let neighbor_movable = [] // array contains all neighbor squares reachable from current position\n\n                const check_idx_u = current_try_postion - w\n                const check_idx_l = current_try_postion - 1\n                const check_idx_r = current_try_postion + 1\n                const check_idx_d = current_try_postion + w\n\n                // destination is reached, no need further checking\n                if (check_idx_u === to_idx || check_idx_l === to_idx || check_idx_r === to_idx || check_idx_d === to_idx) {\n                    try_next = false\n                    isFound = true\n                    try_route.push(to_idx)\n                    break\n                }\n\n                if (check_idx_u >= 0 && indexNotOccupied(check_idx_u) && !exclude(check_idx_u)) {\n                    neighbor_movable.push(check_idx_u)\n                }\n                if (check_idx_l >= line_wrap.start && indexNotOccupied(check_idx_l) && !exclude(check_idx_l)) {\n                    neighbor_movable.push(check_idx_l)\n                }\n                if (check_idx_r < line_wrap.end && indexNotOccupied(check_idx_r) && !exclude(check_idx_r)) {\n                    neighbor_movable.push(check_idx_r)\n                }\n                if (check_idx_d < max_idx && indexNotOccupied(check_idx_d) && !exclude(check_idx_d)) {\n                    neighbor_movable.push(check_idx_d)\n                }\n\n                /*\n                 * try to order reachable neighbors based on distance to destination index\n                 * ex:\n                 * if destination is located in a row above the current position and to the right,\n                 * check for neighbor-square-above and neighbor-square-right\n                 * before those in the left and bottom\n                 */\n\n                /**\n                 * (column, row) representation of square array index\n                 * @param {*} idx input index\n                 * @returns (x, y) = (col_idx, row_idx)\n                 */\n                const x_y = idx => {\n                    return {\n                        x: idx % w,\n                        y: Math.floor(idx / w)\n                    }\n                }\n                /**\n                 * distance between two (x, y) pairs\n                 * @param {*} p1 \n                 * @param {*} p2 \n                 * @returns \n                 */\n                const d_sq = (p1, p2) => {\n                    const dx = p1.x - p2.x\n                    const dy = p1.y - p2.y\n                    return dx * dx + dy * dy\n                }\n                const x_y_of_toIdx = x_y(to_idx)\n\n                const distance = {}\n                distance[check_idx_u] = d_sq(x_y(check_idx_u), x_y_of_toIdx)\n                distance[check_idx_l] = d_sq(x_y(check_idx_l), x_y_of_toIdx)\n                distance[check_idx_r] = d_sq(x_y(check_idx_r), x_y_of_toIdx)\n                distance[check_idx_d] = d_sq(x_y(check_idx_d), x_y_of_toIdx)\n\n                // sort descending by distance, so that the next popped element is the one closest to destination\n                neighbor_movable.sort((x, y) => distance[y] - distance[x])\n\n                // 2. If no reachable neighbor is found, prepare to come back and try for another route\n                if (neighbor_movable.length === 0) {\n                    retry_other_route = true\n                } else {\n                    // otherwise, move to one of the neighbors, and save the remaining in 'valid_mvs' in case\n                    // we need to come back later\n                    valid_mvs[current_try_postion] = neighbor_movable\n                    current_try_postion = neighbor_movable.pop()\n                    try_route.push(current_try_postion)\n                }\n            }\n        }\n        \n        return {\n            found: isFound,\n            route: isFound ? try_route : []\n        }\n    }\n\n    onSquareClicked(i) {\n        if (this.state.squares[i] !== null && this.state.squares[i].type === 'p') {\n            // Detect attempt to move item from this square to another square        \n            this.setState({ selected: i })\n        } else if (this.state.selected != null && this.movable(this.state.selected, i).found) {\n\n            let random_free_square_index = null\n            let idx_of_f_items = this.fItems()\n\n            /*\n             * Save index of all actively changed square in 'active_idx_arr' variable\n             * so that we can check if any set of items is resolved later on\n             * (match-5)\n             * Only save those contain 'p' items as 'f' items should not result in any match-5\n             */\n            let active_idx_arr = [i]\n\n            const squares = this.state.squares.slice();\n\n            /** \n             * A blank square has just been selected as a move-to destination\n             * Remove item from previous square saved in 'selected' state\n             * Add item to newly selected square\n             * Refresh board's state so that related items are re-rendered\n             */\n\n            // Resolve 'f' items\n            if (squares[i] && squares[i].type === 'f') {\n                /**\n                 * This square is occupied by existing item due to user's move\n                 * before future item can acquire it\n                 * Render future item at another random square as 'p' (present) item\n                 */\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove + 1, squares, [i, this.state.selected])\n                const switch_to_idx = random_free_square_index.pop()\n                squares[switch_to_idx] = {\n                    type: 'p',\n                    color: squares[i].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(switch_to_idx)\n\n                // remove this index from 'idx_of_f_items' array\n                idx_of_f_items.splice(idx_of_f_items.indexOf(i), 1)\n            } else {\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove, squares, [i, this.state.selected])\n            }\n            /** For all other f-items with no conflict, render full-size */\n            idx_of_f_items.forEach(idx => {\n                squares[idx] = {\n                    type: 'p',\n                    color: squares[idx].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(idx)\n            })\n\n            // Create new 'f' (future) items (small items) at some random positions\n            for (let i = 0; i < this.numberOfPreRenderedItemAtEachMove; i++) {\n                squares[random_free_square_index.pop()] = {\n                    type: 'f',\n                    color: this.colors[Math.floor(Math.random() * this.colors.length)]\n                }\n            }\n            squares[i] = {\n                type: squares[this.state.selected].type,\n                color: squares[this.state.selected].color\n            }\n            squares[this.state.selected] = null\n            const resolved_idx = this.checkResolved(squares, active_idx_arr)\n            for (const ri of resolved_idx) {\n                squares[ri] = null\n            }\n            this.setState({ squares: squares, selected: null })\n            // Update score\n            if (resolved_idx.length > 0) {\n                this.props.score_incr(resolved_idx.length)\n            }\n        } else {\n            // A blank square has just been selected but no revious item selection \n            // recorded in board's state\n            // Ignore this click event\n            this.setState({ selected: null })\n        }\n    }\n\n    checkResolved(curr_squares, active_idx_arr) {\n        let resolved = []\n        const w = this.w\n        const h = this.h\n\n        active_idx_arr.forEach(i => {\n\n            const base_type = curr_squares[i].type\n            const base_color = curr_squares[i].color\n\n            /**\n             * Check horizontal line [ i % w == 0 ] [ i % w == 1 ] ... [ i % w == w-1 ]\n             */\n            {\n                const line_wrap_start = Math.floor(i / h) * w\n                const line_wrap_end = line_wrap_start + w\n                // count forward\n                let countForward = []\n                for (let incr = i + 1; incr < line_wrap_end && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr++) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - 1; decr >= line_wrap_start && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr--) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n            /**\n             * Check vertical line\n             * [ i - w]\n             * [ i ]\n             * [ i + w]\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += w) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= w) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n             * Check diagonal line \n             * DIRECTION: \\\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w + 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w + 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w - 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w + 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n            * Check diagonal line \n            * DIRECTION: /\n            */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w - 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w - 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w + 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w - 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n        })\n        return resolved\n    }\n\n    renderSquare(idx) {\n        return <Square key={idx}\n            item={this.state.squares[idx]}\n            onClick={() => this.onSquareClicked(idx)}\n            isActivated={this.state.selected === idx} />;\n    }\n\n    renderRows() {\n        let content = [];\n        for (let i = 0; i < this.state.squares.length; i++) {\n            content.push(this.renderSquare(i));\n        }\n        return content\n    }\n\n    render() {\n        return (\n            <div className='game-board'>\n                {this.renderRows()}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\nexport default class Score extends React.Component {\n\n    render() {\n        return (\n            <span>{this.props.score}</span>\n        )\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from './board.js'\nimport Score from './score';\n\nclass Game extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            score: 0\n        }\n        this.increaseScore = this.increaseScore.bind(this)\n    }\n\n    increaseScore(incr) {\n        this.setState({ score: this.state.score + incr })\n    }\n\n    render() {\n        return (\n            <div className=\"game\">\n                <div>\n                    <div className=\"score-board\">\n                        <span>Score: </span>\n                        <Score score={this.state.score} />\n                    </div>\n                    <Board w='9' h='9'  score_incr={this.increaseScore} />\n                </div>\n            </div>\n        );\n    }\n}\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}