{"version":3,"sources":["item.js","square.js","board.js","score.js","index.js"],"names":["Item","height","this","props","y","width","x","cx","cy","r","stroke","strokeWidth","fill","color","React","Component","Square","nextProps","isActivated","item","type","itemOrBlank","style","className","onClick","Board","w","parseInt","h","colors","numberOfPreRenderedItemAtEachMove","state","squares","initArray","selected","arr","Array","noRandomF","freeSquareIdxArr","randomFreeSquareIndex","i","pop","Math","floor","random","length","indexes","sq","push","no_of_random","excludes","free_square_index_arr","fs","reduce","acc","curr","index","includes","fs_idx","splice","idx","st","start","end","from_idx","to_idx","max_idx","current_try_postion","try_route","valid_mvs","retry_other_route","try_next","isFound","failed_idx","exclude","x_y","d_sq","p1","p2","dx","dy","try_fail","indexOf","previous_checkpoint","neighbors","line_wrap","lineWrapOfIndex","neighbor_movable","check_idx_u","check_idx_l","check_idx_r","check_idx_d","valid_check_idx","v_idx","x_y_of_toIdx","distance","sort","found","route","setState","movable","random_free_square_index","idx_of_f_items","fItems","active_idx_arr","slice","switch_to_idx","forEach","resolved_idx","checkResolved","ri","score_incr","curr_squares","resolved","base_type","base_color","line_wrap_start","line_wrap_end","countForward","incr","countBackward","decr","concat","onSquareClicked","content","renderSquare","renderRows","Score","score","Game","increaseScore","bind","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e2b502b0.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Item extends React.Component {\n\n    render() {\n        return (\n            <svg height={this.props.y * 2} width={this.props.x * 2}>\n                <circle cx={this.props.x} cy={this.props.y} r={this.props.r} stroke=\"#555555\" strokeWidth=\"1\" fill={this.props.color} />\n            </svg>\n        );\n    }\n}","import React from 'react';\nimport Item from './item';\n\nexport default class Square extends React.Component {\n\n    shouldComponentUpdate(nextProps) {\n\t\t/** Status */\n        if (this.props.isActivated !== nextProps.isActivated) {\n            return true\n        }\n\t\t/** Item */\n        // blank -> blank (no change)\n        if (this.props.item === null && nextProps.item === null) return false\n        // item -> item: compare all sub-properties (type and color) to see if it's the same item\n        if (this.props.item !== null && nextProps.item !== null) {\n            return this.props.item.type !== nextProps.item.type || this.props.item.color !== nextProps.item.color\n        }\n        // item -> blank or blank -> item\n        return true\n    }\n\n    render() {\n        let itemOrBlank\n        if (this.props.item != null) {\n            itemOrBlank = <Item x='22' y='22'\n                color={this.props.item.color}\n                r={this.props.item.type === 'p' ? 15 : 5} />\n        }\n        const style = this.props.isActivated ? 'square square-active' : 'square'\n        return (\n            <div className={style}\n                onClick={() => this.props.onClick()}>\n                {itemOrBlank}\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport './index.css';\nimport Square from './square.js';\n\nexport default class Board extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.w = parseInt(this.props.w)\n        this.h = parseInt(this.props.h)\n        this.colors = ['#FF9494', '#FFD08B', '#E2E68C', '#A8F0D4', '#9DE2FE', '#C5B8F0', '#FBD8FF']\n        this.numberOfPreRenderedItemAtEachMove = 3\n        this.state = {\n            squares: this.initArray(),\n            selected: null\n        };\n    }\n\n    initArray() {\n        let arr = Array(this.w * this.h).fill(null)\n        const noRandomP = 5;\n        const noRandomF = this.numberOfPreRenderedItemAtEachMove;\n        let freeSquareIdxArr = this.randomFreeSquareIndex(noRandomP + noRandomF, arr, [])\n        for (let i = 0; i < noRandomP; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'p',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        } for (let i = 0; i < noRandomF; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'f',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        }\n        return arr\n    }\n\n    fItems() {\n        var indexes = [], i;\n        const sq = this.state.squares;\n        for (i = 0; i < sq.length; i++) {\n            if (sq[i] && sq[i].type === 'f') {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n\n    randomFreeSquareIndex(no_of_random, squares, excludes) {\n        let free_square_index_arr = []\n\n        /**\n         * An array contains all blank square's index (no item)\n         * We will generate random positions to render related items based on this array\n         * so that all items are rendered in their own separate square\n         */\n        let fs = squares.reduce((acc, curr, index) => {\n            if (curr === null && !excludes.includes(index)) {\n                acc.push(index);\n            }\n            return acc;\n        }, []);\n\n        for (let i = 0; i < no_of_random; i++) {\n\n            // 1. Pick a random index fs_idx of free squares ('fs')\n            // 2. fs[fs_idx] = corresponding index of 'squares' where there's no item occupied (value to return)\n            // 3. Remove element at index free_sqr_idx from free_squares (since it's no longer free)\n\n            const fs_idx = Math.floor(Math.random() * fs.length)\n            free_square_index_arr.push(fs.splice(fs_idx, 1)[0])\n        }\n        return free_square_index_arr\n    }\n\n    lineWrapOfIndex(idx) {\n        const st = Math.floor(idx / this.h) * this.w\n        return {\n            start: st,\n            end: st + this.w\n        }\n    }\n\n    /**\n     * check if there's a clear path for item to move from\n     * one square to another\n     * @param {*} from_idx current position index\n     * @param {*} to_idx destination index\n     * @returns true if a path is found; false otherwise\n     */\n    movable(from_idx, to_idx) {\n        /*\n         * at regular location, item can move to 4 neighbor squares\n         * i: index of item\n         * X: where i can move to, if its index is valid\n         * \n         * also, i-1 and i+1 should be within line boundaries as item at beginning of one row\n         * should not be able to move to the end of the previous row\n         * \n         * [   ] [i-w] [   ]\n         * [i-1] [<i>] [i+1]\n         * [   ] [i+w] [   ]\n         * \n         */\n\n        const sq = this.state.squares\n        const max_idx = sq.length\n        const w = this.w\n\n        const indexNotOccupied = idx => sq[idx] === null || sq[idx].type === 'f'\n\n        /*\n         * - try_route: current route (stack of index) we are checking\n         * - current_try_postion: current index we are chechking\n         * - valid_mvs: save all possible routes that we have not yet checked so that\n         *              we can come back later to check for another route in case the\n         *              current route fails\n         * - retry_other_route: signal that to_idx cannot be reached from the route we're currenty trying\n         * - try_next: signal that we should continue try/retry with next interations as there are\n         *             still possibilities of a clear path found\n         * - isFound: information of our result\n         * - failed_idx: keep track of failed check: there's no path to to_idx from these, so that\n         *               we don't need to same index over and over again in the next iterations\n         */\n        let current_try_postion = from_idx\n        let try_route = [from_idx]\n        let valid_mvs = {}\n        let retry_other_route = false;\n        let try_next = true\n        let isFound = false\n        let failed_idx = []\n\n        /**\n         * check if this index should be excluded from recursively checking\n         * to prevent forming a cycle\n         * either \n         * - it is in the fail-list ('failed_idx') that we already checked, or\n         * - it is included in try_route (that means we have travelled through this idx at some previous iteration)\n         * @param {*} idx index to check\n         * @returns \n         */\n        const exclude = idx => try_route.includes(idx) || failed_idx.includes(idx)\n\n        /**\n         * (column, row) representation of square array index\n         * @param {*} idx input index\n         * @returns (x, y) = (col_idx, row_idx)\n         */\n        const x_y = idx => {\n            return {\n                x: idx % w,\n                y: Math.floor(idx / w)\n            }\n        }\n        /**\n         * distance between two (x, y) pairs\n         * @param {*} p1 \n         * @param {*} p2 \n         * @returns \n         */\n        const d_sq = (p1, p2) => {\n            const dx = p1.x - p2.x\n            const dy = p1.y - p2.y\n            return dx * dx + dy * dy\n        }\n\n        while (try_next) {\n\n            if (retry_other_route) {\n                /**\n                 * there's no way to reach to to_idx using the current route, we have to\n                 * come back to previous check-point and retry for another route\n                 */\n\n                // mark current position index as 'failed'\n                const try_fail = try_route.pop()                \n                failed_idx.push(try_fail)\n\n                // also remove the failed index from our possible-route storage\n                // to reduce number of interations\n                for (const props in valid_mvs) {\n                    if (valid_mvs[props].includes(try_fail)) {\n                        valid_mvs[props].splice(valid_mvs[props].indexOf(try_fail), 1)\n                    }\n                }\n                \n                if (try_route.length === 0) {\n                    // all routes tried but no path found\n                    try_next = false\n                    isFound = false\n                } else {\n                    // return to a previous check-point\n                    const previous_checkpoint = try_route[try_route.length - 1]\n\n                    // retrieve all reachable neighbors of 'curr_from' that we previously store in 'valid_vms'\n                    let neighbors = valid_mvs[previous_checkpoint]\n                    if (!neighbors || neighbors.length === 0) {\n                        // all neighbors have been tried and no success\n                        retry_other_route = true\n                    } else {\n                        // Set up our new current-postion\n                        current_try_postion = neighbors.pop()\n                        try_route.push(current_try_postion)\n                        retry_other_route = false\n                    }\n                }\n            } else {\n                /*\n                 * Continue with the current route as there's no conflict yet\n                 */\n\n                // line boundaries\n                const line_wrap = this.lineWrapOfIndex(current_try_postion)\n\n                // 1. Find all squares reachable from the current position\n\n                let neighbor_movable = [] // array contains all neighbor squares reachable from current position\n\n                const check_idx_u = current_try_postion - w\n                const check_idx_l = current_try_postion - 1\n                const check_idx_r = current_try_postion + 1\n                const check_idx_d = current_try_postion + w\n\n                let valid_check_idx = []\n                if (check_idx_u >= 0) valid_check_idx.push(check_idx_u)\n                if (check_idx_l >= line_wrap.start) valid_check_idx.push(check_idx_l)\n                if (check_idx_r < line_wrap.end) valid_check_idx.push(check_idx_r)\n                if (check_idx_d < max_idx) valid_check_idx.push(check_idx_d)\n\n                // destination is reached, no need further checking\n                if (valid_check_idx.includes(to_idx)) {\n                    try_next = false\n                    isFound = true\n                    try_route.push(to_idx)\n                    break\n                }\n\n                for (const v_idx of valid_check_idx) {\n                    if (indexNotOccupied(v_idx) && !exclude(v_idx)) {\n                        neighbor_movable.push(v_idx)\n                    }\n                }\n\n                /*\n                 * try to order reachable neighbors based on distance to destination index\n                 * ex:\n                 * if destination is located in a row above the current position and to the right,\n                 * check for neighbor-square-above and neighbor-square-right\n                 * before those in the left and bottom\n                 */\n\n                const x_y_of_toIdx = x_y(to_idx)\n\n                const distance = {}\n                distance[check_idx_u] = d_sq(x_y(check_idx_u), x_y_of_toIdx)\n                distance[check_idx_l] = d_sq(x_y(check_idx_l), x_y_of_toIdx)\n                distance[check_idx_r] = d_sq(x_y(check_idx_r), x_y_of_toIdx)\n                distance[check_idx_d] = d_sq(x_y(check_idx_d), x_y_of_toIdx)\n\n                // sort descending by distance, so that the next popped element is the one closest to destination\n                neighbor_movable.sort((x, y) => distance[y] - distance[x])\n\n                // 2. If no reachable neighbor is found, prepare to come back and try for another route\n                if (neighbor_movable.length === 0) {\n                    retry_other_route = true\n                } else {\n                    // otherwise, move to one of the neighbors, and save the remaining in 'valid_mvs' in case\n                    // we need to come back later\n                    valid_mvs[current_try_postion] = neighbor_movable\n                    current_try_postion = neighbor_movable.pop()\n                    try_route.push(current_try_postion)\n                }\n            }\n        }\n        \n        return {\n            found: isFound,\n            route: isFound ? try_route : []\n        }\n    }\n\n    onSquareClicked(i) {\n        if (this.state.squares[i] !== null && this.state.squares[i].type === 'p') {\n            // Detect attempt to move item from this square to another square        \n            this.setState({ selected: i })\n        } else if (this.state.selected != null && this.movable(this.state.selected, i).found) {\n\n            let random_free_square_index = null\n            let idx_of_f_items = this.fItems()\n\n            /*\n             * Save index of all actively changed square in 'active_idx_arr' variable\n             * so that we can check if any set of items is resolved later on\n             * (match-5)\n             * Only save those contain 'p' items as 'f' items should not result in any match-5\n             */\n            let active_idx_arr = [i]\n\n            const squares = this.state.squares.slice();\n\n            /** \n             * A blank square has just been selected as a move-to destination\n             * Remove item from previous square saved in 'selected' state\n             * Add item to newly selected square\n             * Refresh board's state so that related items are re-rendered\n             */\n\n            // Resolve 'f' items\n            if (squares[i] && squares[i].type === 'f') {\n                /**\n                 * This square is occupied by existing item due to user's move\n                 * before future item can acquire it\n                 * Render future item at another random square as 'p' (present) item\n                 */\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove + 1, squares, [i, this.state.selected])\n                const switch_to_idx = random_free_square_index.pop()\n                squares[switch_to_idx] = {\n                    type: 'p',\n                    color: squares[i].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(switch_to_idx)\n\n                // remove this index from 'idx_of_f_items' array\n                idx_of_f_items.splice(idx_of_f_items.indexOf(i), 1)\n            } else {\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove, squares, [i, this.state.selected])\n            }\n            /** For all other f-items with no conflict, render full-size */\n            idx_of_f_items.forEach(idx => {\n                squares[idx] = {\n                    type: 'p',\n                    color: squares[idx].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(idx)\n            })\n\n            // Create new 'f' (future) items (small items) at some random positions\n            for (let i = 0; i < this.numberOfPreRenderedItemAtEachMove; i++) {\n                squares[random_free_square_index.pop()] = {\n                    type: 'f',\n                    color: this.colors[Math.floor(Math.random() * this.colors.length)]\n                }\n            }\n            squares[i] = {\n                type: squares[this.state.selected].type,\n                color: squares[this.state.selected].color\n            }\n            squares[this.state.selected] = null\n            const resolved_idx = this.checkResolved(squares, active_idx_arr)\n            for (const ri of resolved_idx) {\n                squares[ri] = null\n            }\n            this.setState({ squares: squares, selected: null })\n            // Update score\n            if (resolved_idx.length > 0) {\n                this.props.score_incr(resolved_idx.length)\n            }\n        } else {\n            // A blank square has just been selected but no revious item selection \n            // recorded in board's state\n            // Ignore this click event\n            this.setState({ selected: null })\n        }\n    }\n\n    checkResolved(curr_squares, active_idx_arr) {\n        let resolved = []\n        const w = this.w\n        const h = this.h\n\n        active_idx_arr.forEach(i => {\n\n            const base_type = curr_squares[i].type\n            const base_color = curr_squares[i].color\n\n            /**\n             * Check horizontal line [ i % w == 0 ] [ i % w == 1 ] ... [ i % w == w-1 ]\n             */\n            {\n                const line_wrap_start = Math.floor(i / h) * w\n                const line_wrap_end = line_wrap_start + w\n                // count forward\n                let countForward = []\n                for (let incr = i + 1; incr < line_wrap_end && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr++) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - 1; decr >= line_wrap_start && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr--) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n            /**\n             * Check vertical line\n             * [ i - w]\n             * [ i ]\n             * [ i + w]\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += w) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= w) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n             * Check diagonal line \n             * DIRECTION: \\\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w + 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w + 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w - 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w + 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n            * Check diagonal line \n            * DIRECTION: /\n            */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w - 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w - 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w + 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w - 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n        })\n        return resolved\n    }\n\n    renderSquare(idx) {\n        return <Square key={idx}\n            item={this.state.squares[idx]}\n            onClick={() => this.onSquareClicked(idx)}\n            isActivated={this.state.selected === idx} />;\n    }\n\n    renderRows() {\n        let content = [];\n        for (let i = 0; i < this.state.squares.length; i++) {\n            content.push(this.renderSquare(i));\n        }\n        return content\n    }\n\n    render() {\n        return (\n            <div className='game-board'>\n                {this.renderRows()}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\nexport default class Score extends React.Component {\n\n    render() {\n        return (\n            <span>{this.props.score}</span>\n        )\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from './board.js'\nimport Score from './score';\n\nclass Game extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            score: 0\n        }\n        this.increaseScore = this.increaseScore.bind(this)\n    }\n\n    increaseScore(incr) {\n        this.setState({ score: this.state.score + incr })\n    }\n\n    render() {\n        return (\n            <div className=\"game\">\n                <div>\n                    <div className=\"score-board\">\n                        <span>Score: </span>\n                        <Score score={this.state.score} />\n                    </div>\n                    <Board w='9' h='9'  score_incr={this.increaseScore} />\n                </div>\n            </div>\n        );\n    }\n}\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}