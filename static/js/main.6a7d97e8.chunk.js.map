{"version":3,"sources":["item.js","square.js","scanner.js","squareItem.js","utils.js","resolver.js","board.js","score.js","index.js"],"names":["Item","height","this","props","y","width","x","cx","cy","r","stroke","strokeWidth","fill","color","React","PureComponent","Square","onClick","bind","identifier","itemOrBlank","item","type","style","isActivated","className","Scanner","fromValue","toValue","func_getNeighbors","f","reachable_index","reachable_from","newly_added","b","scanner","idx","route","curr","indexOf","cameFrom","push","includes","c_idx","traceBackRoute","reverse","concat","findCommonIndex","constructRouteFromCommonIndex","scanNextLevel","nextLevelNeighbors","from","neighbor_movable","filter","n","isFound","scanNextLevelF","length","tryConstructRouteFromCommonIndex","scanNextLevelB","found","SquareItem","squareItem","s1","s2","random_indexes_in_array","noOfRandom","arr","exclude","result","fs","reduce","acc","index","i","fs_idx","Math","floor","random","splice","checkResolved","active_idx_arr","w","h","resolved","forEach","st","lineWrap","start","end","checkResolved_withOffset","forward_bound","backward_bound","checkResolved_horizontal","checkResolved_vertical","checkResolved_diagonal","offset","countForward","incr","isIdentical","countBackward","decr","Board","parseInt","colors","noRandomF","state","squares","initArray","selected","onSquareSelected","isSquareFree","validNeighborIndex","randomColor","Array","fIdx","pop","newPresentItem","newFutureItem","indexes","sq","isFutureItem","check_idx_u","check_idx_l","check_idx_r","check_idx_d","valid_check_idx","line_wrap","lineWrapOfIndex","v_idx","isFree","from_idx","to_idx","findRoute","setState","random_free_square_index","idx_of_f_items","indexOfCurrentFutureItems","slice","switch_to_idx","copy","resolved_idx","ri","score_incr","isPresentItem","updateState_moveFrom","movable","updateState_moveItemTo","content","renderSquare","renderRows","Score","score","Component","Game","increaseScore","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6a7d97e8.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Item extends React.PureComponent {\n\n    render() {\n        return (\n            <svg height={this.props.y * 2} width={this.props.x * 2}>\n                <circle cx={this.props.x} cy={this.props.y} r={this.props.r} stroke=\"#555555\" strokeWidth=\"1\" fill={this.props.color} />\n            </svg>\n        );\n    }\n}","import React from 'react';\nimport Item from './item';\n\nexport default class Square extends React.PureComponent {\n\n    constructor(props) {\n        super(props)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onClick() {\n        this.props.onClick(this.props.identifier)\n    }\n\n    render() {\n        let itemOrBlank\n        if (this.props.item != null) {\n            itemOrBlank = <Item x='22' y='22'\n                color={this.props.item.color}\n                r={this.props.item.type === 'p' ? 15 : 5} />\n        }\n        const style = this.props.isActivated ? 'square square-active' : 'square'\n        return (\n            <div className={style}\n                onClick={this.onClick}>\n                {itemOrBlank}\n            </div>\n        );\n    }\n}\n","export default class Scanner {\n\n    /**\n     * Object to calculate the route to go from node:@fromValue to node:@toValue\n     * provided that the one step route from a value to its neighbors is supplied\n     * by function @neighborFuncCheck\n     * \n     * @param {*} fromValue\n     * @param {*} toValue\n     * @param {*} func_getNeighbors function used to retrieve valid neighbors of an index\n     * @example neighborFuncCheck = index => [ neighbor_1, neighbor_2, ...]\n     */\n    constructor(fromValue, toValue, func_getNeighbors) {\n        /*\n         * Use fScanner & bScanner to store node reachable from 'fromValue' and 'toValue'\n         * \n         * - reachable_index: node reachable from the original position\n         * - reachable_from: map 1:1 to reachable_index to keep track of route history\n         *                   (we go to reachable_index[i] from reachable_index[reachable_from[i]])\n         * - newly_added: all new reachable idx we have added in the current iteration\n         *                (their neighbors are not yet added to our main list reachable_index\n         *                and should be processed in the next iteration)\n         */\n        this.f = {\n            reachable_index: [fromValue],\n            reachable_from: [fromValue],\n            newly_added: [fromValue]\n        }\n        this.b = {\n            reachable_index: [toValue],\n            reachable_from: [toValue],\n            newly_added: [toValue]\n        }\n        this.func_getNeighbors = func_getNeighbors\n    }\n\n    /**\n    * Construct the route to go from original node to the input node\n    * @param {*} scanner \n    * @param {*} idx \n    * @returns route[ ]\n    */\n    traceBackRoute(scanner, idx) {\n        let route = []\n        let curr = scanner.reachable_index.indexOf(idx)\n        while (curr !== 0) {\n            const cameFrom = scanner.reachable_from[curr]\n            route.push(scanner.reachable_from[cameFrom])\n            curr = cameFrom\n        }\n        return route\n    }\n\n    /**\n     * Find common value in reachable_index array of two input scanners\n     * @param {*} fScanner \n     * @param {*} bScanner \n     * @returns the value found\n     */\n    findCommonIndex() {\n        for (const idx of this.f.reachable_index) {\n            if (this.b.reachable_index.includes(idx)) {\n                return idx\n            }\n        }\n        return -1\n    }\n\n    /**\n     * Construct the route to go from original node of a scanner to the original node of\n     * another scanner based on their common index value\n     * @param {*} fScanner \n     * @param {*} bScanner \n     * @param {*} c_idx \n     * @returns route[ ]\n     */\n    constructRouteFromCommonIndex(c_idx) {\n        let route = this.traceBackRoute(this.f, c_idx)\n        route.reverse()\n        route.push(c_idx)\n        route.concat(this.traceBackRoute(this.b, c_idx))\n        return route\n    }\n\n    tryConstructRouteFromCommonIndex() {\n        const c_idx = this.findCommonIndex()\n        if (c_idx >= 0) {\n            return this.constructRouteFromCommonIndex(c_idx)\n        }\n        return []\n    }\n\n    scanNextLevelF() {\n        this.scanNextLevel(this.f)\n    }\n\n    scanNextLevelB() {\n        this.scanNextLevel(this.b)\n    }\n\n    /**\n     * scan next level of reachable node\n     * \n     * Steps:\n     * 1. for each item of 'newly_added' array, find all reachable neighbors of that item\n     * 2. add new item to 'reachable_index' array, and reference their array index in 'reachable_from'\n     * 3. replace 'newly_added' items with the new ones from step 1\n     * \n     * @param {*} scanner \n     * @returns \n     */\n    scanNextLevel(scanner) {\n        let nextLevelNeighbors = []\n        for (const idx of scanner.newly_added) {\n            const from = scanner.reachable_index.indexOf(idx)\n\n            // 1. Find all values reachable from the current position\n            let neighbor_movable = this.func_getNeighbors(idx)\n            neighbor_movable = neighbor_movable.filter(n => !scanner.reachable_index.includes(n))\n\n            for (const n of neighbor_movable) {\n                scanner.reachable_index.push(n)\n                scanner.reachable_from.push(from)\n            }\n            nextLevelNeighbors = nextLevelNeighbors.concat(neighbor_movable)\n        }\n        scanner.newly_added = nextLevelNeighbors\n        return scanner\n    }\n\n    findRoute() {\n        let isFound = false\n        let route = []\n\n        /*\n         * During each iteration\n         * 1. Collect next-level reachable nodes of both 'from' and 'to' into fScanner and bScanner\n         * 2. Check for a common index between two scanners. \n         *    If yes, that means our two scanners have encounter each other half-way. From that common index, \n         *    trace back to construct the route\n         */\n\n        while (!isFound) {\n\n            // 1. Collect next-level reachable squares\n            this.scanNextLevelF()\n            if (this.f.newly_added.length === 0) {\n                /*\n                 * fScanner already includes all reachable squares from 'from_idx'\n                 * if 'to_idx' can be reached from 'from_idx', it should have been\n                 * resolved in the previous iteration\n                 */\n                isFound = false\n                break\n            }\n\n            // 2. Check for a common index\n            route = this.tryConstructRouteFromCommonIndex()\n            if (route && route.length > 0) {\n                isFound = true\n                break\n            }\n\n            this.scanNextLevelB()\n            if (this.b.newly_added.length === 0) {\n                /*\n                 * bScanner already includes all reachable squares from 'to_idx'\n                 * if 'from_idx' can be reached from 'to_idx', it should have been\n                 * resolved in the previous iteration\n                 */\n                isFound = false\n                break\n            }\n\n            // Check for a common index again as scanner.b is updated\n            route = this.tryConstructRouteFromCommonIndex()\n            if (route && route.length > 0) {\n                isFound = true\n                break\n            }\n        }\n        return {\n            found: isFound,\n            route: route\n        }\n    }\n}\n","export default class SquareItem {\n\n    constructor(type, color) {\n        this.type = type\n        this.color = color\n    }\n\n    /**\n     * Create a new SquareItem by copying all properties of the input item\n     * @param {*} squareItem \n     * @returns \n     */\n    static copy(squareItem) {\n        return new SquareItem(squareItem.type, squareItem.color)\n    }\n\n    /**\n     * Check if two items is identical\n     * @param {*} s1 \n     * @param {*} s2 \n     * @returns \n     */\n    static isIdentical(s1, s2) {\n        if (s1 === null && s2 === null) return true\n        if (s1 === null || s2 === null) return false\n        return s1.type === s2.type && s1.color === s2.color\n    }\n\n    isPresentItem() {\n        return this.type === 'p'\n    }\n\n    isFutureItem() {\n        return this.type === 'f'\n    }\n\n    isFree() {\n        return this.type !== 'p'\n    }\n}","/**\n * Get random indexes of an array with some filter conditions\n * @param {*} noOfRandom number of random indexes of input array to be generated\n * @param {*} arr input array\n * @param {*} filter filter condition for index of array\n * @param {*} exclude list of indexes to be excluded\n * @returns an array of random indexes satisfied \n * \n * @example \n * random_indexes_in_array(1, [1, A, Z, 4], idx => idx !== 4, [Z])\n * result: [1], or result: [2]\n */\nexport function random_indexes_in_array(noOfRandom, arr, filter, exclude) {\n    let result = []\n\n    /*\n     * fs: an array contains all valid arr's indexes\n     * input func (conditionFunc => true/false) is used to decide whether the index is valid\n     */\n    let fs = arr.reduce((acc, curr, index) => {\n        if (curr === null && filter(index) && !exclude.includes(index)) {\n            acc.push(index);\n        }\n        return acc;\n    }, []);\n\n    for (let i = 0; i < noOfRandom; i++) {\n\n        // 1. Pick a random index fs_idx of free squares ('fs')\n        // 2. fs[fs_idx] = corresponding index of 'squares' where there's no item occupied (value to return)\n        // 3. Remove element at index free_sqr_idx from free_squares (since it's no longer free)\n\n        const fs_idx = Math.floor(Math.random() * fs.length)\n        result.push(fs.splice(fs_idx, 1)[0])\n    }\n    return result\n}","import SquareItem from './squareItem'\n\n/**\n * Check for a match-5+\n * \n * This function checks for elements surrounding the active indexes in *active_idx_arr*\n * to see if a vertical/horizontal or diagonal line with 5+ items of the same color is form \n * \n * @param {*} arr array represents a 2-dimension (*w x h*) grid of items\n * @param {*} active_idx_arr array of all indexes to be checked for a match\n * @param {*} dimen { w, h } *arr*'s dimensions\n * @returns array contains indexes of *arr* that involve in a match\n */\nexport function checkResolved(arr, active_idx_arr, { w, h }) {\n    let resolved = []\n\n    active_idx_arr.forEach(i => {\n        resolved = resolved\n            .concat(checkResolved_horizontal(arr, i, { w, h }))\n            .concat(checkResolved_vertical(arr, i, { w, h }))\n            .concat(checkResolved_diagonal(arr, i, { w, h }))\n    })\n    return resolved\n}\n\n\nfunction checkResolved_horizontal(arr, i, { w, h }) {\n    /* Check horizontal line\n     * [ i % w == 0 ] [ i % w == 1 ] ... [ i % w == w-1 ] \n     */\n    const st = Math.floor(i / h) * w\n    const lineWrap = {\n        start: st,\n        end: st + w\n    }\n    return checkResolved_withOffset(arr, i, 1, {\n        forward_bound: lineWrap.end,\n        backward_bound: lineWrap.start\n    })\n}\n\nfunction checkResolved_vertical(arr, i, { w, h }) {\n    /*\n    * Check vertical line\n    * [ i - w]\n    * [ i ]\n    * [ i + w]\n    */\n    return checkResolved_withOffset(arr, i, w, {\n        forward_bound: arr.length,\n        backward_bound: 0\n    })\n}\n\nfunction checkResolved_diagonal(arr, i, { w, h }) {\n    let resolved = []\n\n    /*\n     * Check diagonal line \n     * DIRECTION: \\\n     */\n    resolved = resolved.concat(checkResolved_withOffset(arr, i, w + 1, {\n        forward_bound: arr.length,\n        backward_bound: 0\n    }))\n\n    /*\n    * Check diagonal line \n    * DIRECTION: /\n    */\n    resolved = resolved.concat(checkResolved_withOffset(arr, i, w - 1, {\n        forward_bound: arr.length,\n        backward_bound: 0\n    }))\n    return resolved\n}\n\nfunction checkResolved_withOffset(arr, i, offset, { forward_bound, backward_bound }) {\n\n    let resolved = []\n\n    // count forward\n    let countForward = []\n    for (let incr = i + offset; incr < forward_bound\n        && SquareItem.isIdentical(arr[incr], arr[i]); incr += offset) {\n        countForward.push(incr)\n    }\n    // count backward\n    let countBackward = []\n    for (let decr = i - offset; decr >= backward_bound\n        && SquareItem.isIdentical(arr[decr], arr[i]); decr -= offset) {\n        countBackward.push(decr)\n    }\n    // total:\n    const count = countBackward.length + countForward.length + 1\n    if (count >= 5) {\n        resolved = [i].concat(countForward, countBackward)\n    }\n    return resolved\n}","import React from 'react';\nimport './index.css';\nimport Square from './square.js';\nimport Scanner from './scanner.js';\nimport SquareItem from './squareItem';\nimport { random_indexes_in_array } from './utils'\nimport { checkResolved } from './resolver'\n\nexport default class Board extends React.PureComponent {\n\n    constructor(props) {\n        super(props);\n        this.w = parseInt(this.props.w)\n        this.h = parseInt(this.props.h)\n        this.colors = ['#FF9494', '#FFD08B', '#E2E68C', '#A8F0D4', '#9DE2FE', '#C5B8F0', '#FBD8FF']\n        this.noRandomF = 3\n        this.state = {\n            squares: this.initArray(),\n            selected: null\n        };\n        this.onSquareSelected = this.onSquareSelected.bind(this)\n        this.isSquareFree = this.isSquareFree.bind(this)\n        this.validNeighborIndex = this.validNeighborIndex.bind(this)\n    }\n\n    randomColor() {\n        return this.colors[Math.floor(Math.random() * this.colors.length)]\n    }\n\n    newPresentItem(color) {\n        return new SquareItem('p', color ? color : this.randomColor())\n    }\n\n    newFutureItem() {\n        return new SquareItem('f', this.randomColor())\n    }\n\n    initArray() {\n        let arr = Array(this.w * this.h).fill(null)\n        const noRandomP = 5;\n        const noRandomF = this.noRandomF;\n        /*\n         * Generate random positions for present items and future items using random_indexes_in_array:\n         * board hasn't been initialized yet so there's no pre-occupied items in any square\n         * - pass a dummy filter condition () => true\n         * - and a dummy exclude array []\n         */\n        let fIdx = random_indexes_in_array(noRandomP + noRandomF, arr, () => true, [])\n\n        for (let i = 0; i < noRandomP; i++) arr[fIdx.pop()] = this.newPresentItem()\n        for (let i = 0; i < noRandomF; i++) arr[fIdx.pop()] = this.newFutureItem()\n\n        return arr\n    }\n\n    indexOfCurrentFutureItems() {\n        var indexes = [], i;\n        const sq = this.state.squares;\n        for (i = 0; i < sq.length; i++) {\n            if (sq[i] && sq[i].isFutureItem()) {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n\n    lineWrapOfIndex(idx) {\n        const st = Math.floor(idx / this.h) * this.w\n        return {\n            start: st,\n            end: st + this.w\n        }\n    }\n\n    /**\n     * function to retrieve neighbor squares that item at square idx can move to\n     * @param {*} idx\n     * @returns \n     */\n    validNeighborIndex(idx) {\n        const check_idx_u = idx - this.w\n        const check_idx_l = idx - 1\n        const check_idx_r = idx + 1\n        const check_idx_d = idx + this.w\n\n        // Check for boundaries:\n        let valid_check_idx = []\n        const line_wrap = this.lineWrapOfIndex(idx)\n\n        if (check_idx_u >= 0) valid_check_idx.push(check_idx_u)\n        if (check_idx_l >= line_wrap.start) valid_check_idx.push(check_idx_l)\n        if (check_idx_r < line_wrap.end) valid_check_idx.push(check_idx_r)\n        if (check_idx_d < this.w * this.h) valid_check_idx.push(check_idx_d)\n\n        return valid_check_idx.filter(v_idx => this.isSquareFree(v_idx))\n    }\n\n    isSquareFree(idx) {\n        return this.state.squares[idx] === null || this.state.squares[idx].isFree()\n    }\n\n    // CLICK-EVENT ===================================================================\n\n    /**\n     * check if there's a clear path for item to move from\n     * one square to another\n     * @param {*} from_idx current position index\n     * @param {*} to_idx destination index\n     * @returns true if a path is found; false otherwise\n     */\n    movable(from_idx, to_idx) {\n        /*\n         * at regular location, item can move to 4 neighbor squares\n         * i: index of item\n         * X: where i can move to, if its index is valid\n         * \n         * also, i-1 and i+1 should be within line boundaries as item at beginning of one row\n         * should not be able to move to the end of the previous row\n         * \n         * [   ] [i-w] [   ]\n         * [i-1] [<i>] [i+1]\n         * [   ] [i+w] [   ]\n         * \n         */\n        const scanner = new Scanner(from_idx, to_idx, this.validNeighborIndex)\n        const findRoute = scanner.findRoute()\n\n        return {\n            found: findRoute.found,\n            route: findRoute.route\n        }\n    }\n\n    /**\n     * signal that an item is selected by user click, and may be moved\n     * to another position at next click event\n     * @param {*} i \n     */\n    updateState_moveFrom(i) {\n        this.setState({ selected: i })\n    }\n\n    /**\n     * logic to update game state when moving an item at square *this.state.selected*\n     * to square *i* which is already confirmed to be a blank square\n     * @param {*} i index of destination square\n     */\n    updateState_moveItemTo(i) {\n        /*\n         * A blank square has just been selected as a move-to destination\n         * - Remove item from previous square saved in 'selected' state\n         * - Add item to newly selected square\n         * - Refresh board's state so that related items are re-rendered\n         */\n\n        let random_free_square_index = null\n        let idx_of_f_items = this.indexOfCurrentFutureItems()\n\n        /*\n         * Save index of all actively changed square in active_idx_arr variable\n         * so that we can check if any set of items is resolved later on (eg. result in a match-5+)\n         * Only save those contain 'p' items as 'f' items should not result in any match-5\n         */\n        let active_idx_arr = [i]\n\n        const squares = this.state.squares.slice();\n\n        /*\n         * Resolve 'f' items:\n         * - Extra check to see if we are moving the selected item to a square where a future item is\n         * expected to be rendered\n         * - If yes, find another random square to render that 'f' item as 'p' \n         */\n        if (squares[i] && squares[i].isFutureItem()) {\n            random_free_square_index = random_indexes_in_array(this.noRandomF + 1, squares, this.isSquareFree, [i, this.state.selected])\n            const switch_to_idx = random_free_square_index.pop()\n            squares[switch_to_idx] = this.newPresentItem(squares[i].color)\n\n            // f -> p: add ref to active_idx_arr\n            active_idx_arr.push(switch_to_idx)\n\n            // remove this index from 'idx_of_f_items' array\n            idx_of_f_items.splice(idx_of_f_items.indexOf(i), 1)\n        } else {\n            random_free_square_index = random_indexes_in_array(this.noRandomF, squares, this.isSquareFree, [i, this.state.selected])\n        }\n\n        /* For all other f-items with no conflict, render full-size now */\n        idx_of_f_items.forEach(idx => {\n            squares[idx] = this.newPresentItem(squares[idx].color)\n            // f -> p: add ref to active_idx_arr\n            active_idx_arr.push(idx)\n        })\n\n        // Create new 'f' (future) items (small items) at some random positions\n        for (let i = 0; i < this.noRandomF; i++) {\n            squares[random_free_square_index.pop()] = this.newFutureItem()\n        }\n\n        /* update move-to position with properties of selected item */\n        squares[i] = SquareItem.copy(squares[this.state.selected])\n\n        /* remove selected item from its previous position */\n        squares[this.state.selected] = null\n\n        /* check if any match-5+ is found so that we clear them from board game and update score */\n        const resolved_idx = checkResolved(squares, active_idx_arr, { w: this.w, h: this.h })\n        for (const ri of resolved_idx) {\n            squares[ri] = null\n        }\n\n        /* signal react to re-render board */\n        this.setState({ squares: squares, selected: null })\n\n        // Update score: send signal to parent component (Game)\n        if (resolved_idx.length > 0) {\n            this.props.score_incr(resolved_idx.length)\n        }\n    }\n\n    /**\n     * calculation logic and possible state changes when a click event is performed on a square\n     * @param {*} i index of selected square in *squares* array\n     * @returns \n     */\n    onSquareSelected(i) {\n\n        // Detect attempt to move item from this square to another square        \n        if (this.state.squares[i] && this.state.squares[i].isPresentItem()) {\n            // An item is selected to be moved later on\n            this.updateState_moveFrom(i)\n            return\n        }\n\n        if (this.state.selected != null /* A destination to move selected item to has been selected */\n            && this.movable(this.state.selected, i).found /* and a valid path is confirmed */) {\n            this.updateState_moveItemTo(i)\n            return\n        }\n        // Else: Ignore this click event since a blank square has just been selected\n        // but no previous item-to-move is recorded in board's state\n    }\n\n    // REACT-RENDER ===================================================================\n\n    renderSquare(idx) {\n        return <Square key={idx}\n            item={this.state.squares[idx]}\n            identifier={idx}\n            onClick={this.onSquareSelected}\n            isActivated={this.state.selected === idx} />;\n    }\n\n    renderRows() {\n        let content = [];\n        for (let i = 0; i < this.state.squares.length; i++) {\n            content.push(this.renderSquare(i));\n        }\n        return content\n    }\n\n    render() {\n        return (\n            <div className='game-board'>\n                {this.renderRows()}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\nexport default class Score extends React.Component {\n\n    render() {\n        return (\n            <span>{this.props.score}</span>\n        )\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from './board.js'\nimport Score from './score';\n\nclass Game extends React.PureComponent {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            score: 0\n        }\n        this.increaseScore = this.increaseScore.bind(this)\n    }\n\n    increaseScore(incr) {\n        this.setState({ score: this.state.score + incr })\n    }\n\n    render() {\n        return (\n            <div className=\"game\">\n                <div>\n                    <div className=\"score-board\">\n                        <span>Score: </span>\n                        <Score score={this.state.score} />\n                    </div>\n                    <Board w='9' h='9'  score_incr={this.increaseScore} />\n                </div>\n            </div>\n        );\n    }\n}\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}