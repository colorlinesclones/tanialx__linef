{"version":3,"sources":["item.js","square.js","scanner.js","board.js","score.js","index.js"],"names":["Item","height","this","props","y","width","x","cx","cy","r","stroke","strokeWidth","fill","color","React","Component","Square","nextProps","isActivated","item","type","itemOrBlank","style","className","onClick","Scanner","fromValue","toValue","func_getNeighbors","f","reachable_index","reachable_from","newly_added","b","scanner","idx","route","curr","indexOf","cameFrom","push","includes","c_idx","traceBackRoute","reverse","concat","findCommonIndex","constructRouteFromCommonIndex","scanNextLevel","nextLevelNeighbors","from","neighbor_movable","filter","n","isFound","scanNextLevelF","length","tryConstructRouteFromCommonIndex","scanNextLevelB","found","Board","validNeighborIndex","check_idx_u","w","check_idx_l","check_idx_r","check_idx_d","valid_check_idx","line_wrap","lineWrapOfIndex","start","end","h","v_idx","indexNotOccupied","parseInt","colors","numberOfPreRenderedItemAtEachMove","state","squares","initArray","selected","arr","Array","noRandomF","freeSquareIdxArr","randomFreeSquareIndex","i","pop","Math","floor","random","indexes","sq","no_of_random","excludes","free_square_index_arr","fs","reduce","acc","index","fs_idx","splice","st","from_idx","to_idx","findRoute","setState","movable","random_free_square_index","idx_of_f_items","fItems","active_idx_arr","slice","switch_to_idx","forEach","resolved_idx","checkResolved","ri","score_incr","curr_squares","resolved","base_type","base_color","line_wrap_start","line_wrap_end","countForward","incr","countBackward","decr","onSquareClicked","content","renderSquare","renderRows","Score","score","Game","increaseScore","bind","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.959c6791.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Item extends React.Component {\n\n    render() {\n        return (\n            <svg height={this.props.y * 2} width={this.props.x * 2}>\n                <circle cx={this.props.x} cy={this.props.y} r={this.props.r} stroke=\"#555555\" strokeWidth=\"1\" fill={this.props.color} />\n            </svg>\n        );\n    }\n}","import React from 'react';\nimport Item from './item';\n\nexport default class Square extends React.Component {\n\n    shouldComponentUpdate(nextProps) {\n\t\t/** Status */\n        if (this.props.isActivated !== nextProps.isActivated) {\n            return true\n        }\n\t\t/** Item */\n        // blank -> blank (no change)\n        if (this.props.item === null && nextProps.item === null) return false\n        // item -> item: compare all sub-properties (type and color) to see if it's the same item\n        if (this.props.item !== null && nextProps.item !== null) {\n            return this.props.item.type !== nextProps.item.type || this.props.item.color !== nextProps.item.color\n        }\n        // item -> blank or blank -> item\n        return true\n    }\n\n    render() {\n        let itemOrBlank\n        if (this.props.item != null) {\n            itemOrBlank = <Item x='22' y='22'\n                color={this.props.item.color}\n                r={this.props.item.type === 'p' ? 15 : 5} />\n        }\n        const style = this.props.isActivated ? 'square square-active' : 'square'\n        return (\n            <div className={style}\n                onClick={() => this.props.onClick()}>\n                {itemOrBlank}\n            </div>\n        );\n    }\n}\n","export default class Scanner {\n\n    /**\n     * Object to calculate the route to go from node:@fromValue to node:@toValue\n     * provided that the one step route from a value to its neighbors is supplied\n     * by function @neighborFuncCheck\n     * \n     * @param {*} fromValue\n     * @param {*} toValue\n     * @param {*} func_getNeighbors function used to retrieve valid neighbors of an index\n     * @example neighborFuncCheck = index => [ neighbor_1, neighbor_2, ...]\n     */\n    constructor(fromValue, toValue, func_getNeighbors) {\n        /*\n         * Use fScanner & bScanner to store node reachable from 'fromValue' and 'toValue'\n         * \n         * - reachable_index: node reachable from the original position\n         * - reachable_from: map 1:1 to reachable_index to keep track of route history\n         *                   (we go to reachable_index[i] from reachable_index[reachable_from[i]])\n         * - newly_added: all new reachable idx we have added in the current iteration\n         *                (their neighbors are not yet added to our main list reachable_index\n         *                and should be processed in the next iteration)\n         */\n        this.f = {\n            reachable_index: [fromValue],\n            reachable_from: [fromValue],\n            newly_added: [fromValue]\n        }\n        this.b = {\n            reachable_index: [toValue],\n            reachable_from: [toValue],\n            newly_added: [toValue]\n        }\n        this.func_getNeighbors = func_getNeighbors\n    }\n\n    /**\n    * Construct the route to go from original node to the input node\n    * @param {*} scanner \n    * @param {*} idx \n    * @returns route[ ]\n    */\n    traceBackRoute(scanner, idx) {\n        let route = []\n        let curr = scanner.reachable_index.indexOf(idx)\n        while (curr !== 0) {\n            const cameFrom = scanner.reachable_from[curr]\n            route.push(scanner.reachable_from[cameFrom])\n            curr = cameFrom\n        }\n        return route\n    }\n\n    /**\n     * Find common value in reachable_index array of two input scanners\n     * @param {*} fScanner \n     * @param {*} bScanner \n     * @returns the value found\n     */\n    findCommonIndex() {\n        for (const idx of this.f.reachable_index) {\n            if (this.b.reachable_index.includes(idx)) {\n                return idx\n            }\n        }\n        return -1\n    }\n\n    /**\n     * Construct the route to go from original node of a scanner to the original node of\n     * another scanner based on their common index value\n     * @param {*} fScanner \n     * @param {*} bScanner \n     * @param {*} c_idx \n     * @returns route[ ]\n     */\n    constructRouteFromCommonIndex(c_idx) {\n        let route = this.traceBackRoute(this.f, c_idx)\n        route.reverse()\n        route.push(c_idx)\n        route.concat(this.traceBackRoute(this.b, c_idx))\n        return route\n    }\n\n    tryConstructRouteFromCommonIndex() {\n        const c_idx = this.findCommonIndex()\n        if (c_idx >= 0) {\n            return this.constructRouteFromCommonIndex(c_idx)\n        }\n        return []\n    }\n\n    scanNextLevelF() {\n        this.scanNextLevel(this.f)\n    }\n\n    scanNextLevelB() {\n        this.scanNextLevel(this.b)\n    }\n\n    /**\n     * scan next level of reachable node\n     * \n     * Steps:\n     * 1. for each item of 'newly_added' array, find all reachable neighbors of that item\n     * 2. add new item to 'reachable_index' array, and reference their array index in 'reachable_from'\n     * 3. replace 'newly_added' items with the new ones from step 1\n     * \n     * @param {*} scanner \n     * @returns \n     */\n    scanNextLevel(scanner) {\n        let nextLevelNeighbors = []\n        for (const idx of scanner.newly_added) {\n            const from = scanner.reachable_index.indexOf(idx)\n\n            // 1. Find all values reachable from the current position\n            let neighbor_movable = this.func_getNeighbors(idx)\n            neighbor_movable = neighbor_movable.filter(n => !scanner.reachable_index.includes(n))\n\n            for (const n of neighbor_movable) {\n                scanner.reachable_index.push(n)\n                scanner.reachable_from.push(from)\n            }\n            nextLevelNeighbors = nextLevelNeighbors.concat(neighbor_movable)\n        }\n        scanner.newly_added = nextLevelNeighbors\n        return scanner\n    }\n\n    findRoute() {\n        let isFound = false\n        let route = []\n\n        /*\n         * During each iteration\n         * 1. Collect next-level reachable nodes of both 'from' and 'to' into fScanner and bScanner\n         * 2. Check for a common index between two scanners. \n         *    If yes, that means our two scanners have encounter each other half-way. From that common index, \n         *    trace back to construct the route\n         */\n\n        while (!isFound) {\n\n            // 1. Collect next-level reachable squares\n            this.scanNextLevelF()\n            if (this.f.newly_added.length === 0) {\n                /*\n                 * fScanner already includes all reachable squares from 'from_idx'\n                 * if 'to_idx' can be reached from 'from_idx', it should have been\n                 * resolved in the previous iteration\n                 */\n                isFound = false\n                break\n            }\n\n            // 2. Check for a common index\n            route = this.tryConstructRouteFromCommonIndex()\n            if (route && route.length > 0) {\n                isFound = true\n                break\n            }\n\n            this.scanNextLevelB()\n            if (this.b.newly_added.length === 0) {\n                /*\n                 * bScanner already includes all reachable squares from 'to_idx'\n                 * if 'from_idx' can be reached from 'to_idx', it should have been\n                 * resolved in the previous iteration\n                 */\n                isFound = false\n                break\n            }\n\n            // Check for a common index again as scanner.b is updated\n            route = this.tryConstructRouteFromCommonIndex()\n            if (route && route.length > 0) {\n                isFound = true\n                break\n            }\n        }\n        return {\n            found: isFound,\n            route: route\n        }\n    }\n}\n","import React from 'react';\nimport './index.css';\nimport Square from './square.js';\nimport Scanner from './scanner.js';\n\nexport default class Board extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.w = parseInt(this.props.w)\n        this.h = parseInt(this.props.h)\n        this.colors = ['#FF9494', '#FFD08B', '#E2E68C', '#A8F0D4', '#9DE2FE', '#C5B8F0', '#FBD8FF']\n        this.numberOfPreRenderedItemAtEachMove = 3\n        this.state = {\n            squares: this.initArray(),\n            selected: null\n        };\n    }\n\n    initArray() {\n        let arr = Array(this.w * this.h).fill(null)\n        const noRandomP = 5;\n        const noRandomF = this.numberOfPreRenderedItemAtEachMove;\n        let freeSquareIdxArr = this.randomFreeSquareIndex(noRandomP + noRandomF, arr, [])\n        for (let i = 0; i < noRandomP; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'p',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        } for (let i = 0; i < noRandomF; i++) {\n            arr[freeSquareIdxArr.pop()] = {\n                type: 'f',\n                color: this.colors[Math.floor(Math.random() * this.colors.length)]\n            }\n        }\n        return arr\n    }\n\n    fItems() {\n        var indexes = [], i;\n        const sq = this.state.squares;\n        for (i = 0; i < sq.length; i++) {\n            if (sq[i] && sq[i].type === 'f') {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n\n    randomFreeSquareIndex(no_of_random, squares, excludes) {\n        let free_square_index_arr = []\n\n        /**\n         * An array contains all blank square's index (no item)\n         * We will generate random positions to render related items based on this array\n         * so that all items are rendered in their own separate square\n         */\n        let fs = squares.reduce((acc, curr, index) => {\n            if (curr === null && !excludes.includes(index)) {\n                acc.push(index);\n            }\n            return acc;\n        }, []);\n\n        for (let i = 0; i < no_of_random; i++) {\n\n            // 1. Pick a random index fs_idx of free squares ('fs')\n            // 2. fs[fs_idx] = corresponding index of 'squares' where there's no item occupied (value to return)\n            // 3. Remove element at index free_sqr_idx from free_squares (since it's no longer free)\n\n            const fs_idx = Math.floor(Math.random() * fs.length)\n            free_square_index_arr.push(fs.splice(fs_idx, 1)[0])\n        }\n        return free_square_index_arr\n    }\n\n    lineWrapOfIndex(idx) {\n        const st = Math.floor(idx / this.h) * this.w\n        return {\n            start: st,\n            end: st + this.w\n        }\n    }\n\n    /**\n     * function to retrieve neighbor squares that item at square idx can move to\n     * @param {*} idx\n     * @returns \n     */\n    validNeighborIndex = idx => {\n        const check_idx_u = idx - this.w\n        const check_idx_l = idx - 1\n        const check_idx_r = idx + 1\n        const check_idx_d = idx + this.w\n\n        // Check for boundaries:\n        let valid_check_idx = []\n        const line_wrap = this.lineWrapOfIndex(idx)\n\n        if (check_idx_u >= 0) valid_check_idx.push(check_idx_u)\n        if (check_idx_l >= line_wrap.start) valid_check_idx.push(check_idx_l)\n        if (check_idx_r < line_wrap.end) valid_check_idx.push(check_idx_r)\n        if (check_idx_d < this.w * this.h) valid_check_idx.push(check_idx_d)\n\n        return valid_check_idx.filter(v_idx => this.indexNotOccupied(v_idx))\n    }\n\n    indexNotOccupied(idx) {\n        return this.state.squares[idx] === null || this.state.squares[idx].type === 'f'\n    }\n    /**\n     * check if there's a clear path for item to move from\n     * one square to another\n     * @param {*} from_idx current position index\n     * @param {*} to_idx destination index\n     * @returns true if a path is found; false otherwise\n     */\n    movable(from_idx, to_idx) {\n        /*\n         * at regular location, item can move to 4 neighbor squares\n         * i: index of item\n         * X: where i can move to, if its index is valid\n         * \n         * also, i-1 and i+1 should be within line boundaries as item at beginning of one row\n         * should not be able to move to the end of the previous row\n         * \n         * [   ] [i-w] [   ]\n         * [i-1] [<i>] [i+1]\n         * [   ] [i+w] [   ]\n         * \n         */        \n        const scanner = new Scanner(from_idx, to_idx, this.validNeighborIndex)\n        const findRoute = scanner.findRoute()\n        \n        return {\n            found: findRoute.found,\n            route: findRoute.route\n        }\n    }\n\n    onSquareClicked(i) {\n        if (this.state.squares[i] !== null && this.state.squares[i].type === 'p') {\n            // Detect attempt to move item from this square to another square        \n            this.setState({ selected: i })\n        } else if (this.state.selected != null && this.movable(this.state.selected, i).found) {\n\n            let random_free_square_index = null\n            let idx_of_f_items = this.fItems()\n\n            /*\n             * Save index of all actively changed square in 'active_idx_arr' variable\n             * so that we can check if any set of items is resolved later on\n             * (match-5)\n             * Only save those contain 'p' items as 'f' items should not result in any match-5\n             */\n            let active_idx_arr = [i]\n\n            const squares = this.state.squares.slice();\n\n            /** \n             * A blank square has just been selected as a move-to destination\n             * Remove item from previous square saved in 'selected' state\n             * Add item to newly selected square\n             * Refresh board's state so that related items are re-rendered\n             */\n\n            // Resolve 'f' items\n            if (squares[i] && squares[i].type === 'f') {\n                /**\n                 * This square is occupied by existing item due to user's move\n                 * before future item can acquire it\n                 * Render future item at another random square as 'p' (present) item\n                 */\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove + 1, squares, [i, this.state.selected])\n                const switch_to_idx = random_free_square_index.pop()\n                squares[switch_to_idx] = {\n                    type: 'p',\n                    color: squares[i].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(switch_to_idx)\n\n                // remove this index from 'idx_of_f_items' array\n                idx_of_f_items.splice(idx_of_f_items.indexOf(i), 1)\n            } else {\n                random_free_square_index = this.randomFreeSquareIndex(this.numberOfPreRenderedItemAtEachMove, squares, [i, this.state.selected])\n            }\n            /** For all other f-items with no conflict, render full-size */\n            idx_of_f_items.forEach(idx => {\n                squares[idx] = {\n                    type: 'p',\n                    color: squares[idx].color\n                }\n                // f -> p: add ref to active_idx_arr\n                active_idx_arr.push(idx)\n            })\n\n            // Create new 'f' (future) items (small items) at some random positions\n            for (let i = 0; i < this.numberOfPreRenderedItemAtEachMove; i++) {\n                squares[random_free_square_index.pop()] = {\n                    type: 'f',\n                    color: this.colors[Math.floor(Math.random() * this.colors.length)]\n                }\n            }\n            squares[i] = {\n                type: squares[this.state.selected].type,\n                color: squares[this.state.selected].color\n            }\n            squares[this.state.selected] = null\n            const resolved_idx = this.checkResolved(squares, active_idx_arr)\n            for (const ri of resolved_idx) {\n                squares[ri] = null\n            }\n            this.setState({ squares: squares, selected: null })\n            // Update score\n            if (resolved_idx.length > 0) {\n                this.props.score_incr(resolved_idx.length)\n            }\n        } else {\n            // A blank square has just been selected but no revious item selection \n            // recorded in board's state\n            // Ignore this click event\n            this.setState({ selected: null })\n        }\n    }\n\n    checkResolved(curr_squares, active_idx_arr) {\n        let resolved = []\n        const w = this.w\n        const h = this.h\n\n        active_idx_arr.forEach(i => {\n\n            const base_type = curr_squares[i].type\n            const base_color = curr_squares[i].color\n\n            /**\n             * Check horizontal line [ i % w == 0 ] [ i % w == 1 ] ... [ i % w == w-1 ]\n             */\n            {\n                const line_wrap_start = Math.floor(i / h) * w\n                const line_wrap_end = line_wrap_start + w\n                // count forward\n                let countForward = []\n                for (let incr = i + 1; incr < line_wrap_end && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr++) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - 1; decr >= line_wrap_start && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr--) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n            /**\n             * Check vertical line\n             * [ i - w]\n             * [ i ]\n             * [ i + w]\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += w) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= w) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n             * Check diagonal line \n             * DIRECTION: \\\n             */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w + 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w + 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w - 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w + 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n\n            /**\n            * Check diagonal line \n            * DIRECTION: /\n            */\n            {\n                // count forward\n                let countForward = []\n                for (let incr = i + w - 1; incr < curr_squares.length && curr_squares[incr]\n                    && curr_squares[incr].type === base_type\n                    && curr_squares[incr].color === base_color; incr += (w - 1)) {\n                    countForward.push(incr)\n                }\n                // count backward\n                let countBackward = []\n                for (let decr = i - w + 1; decr >= 0 && curr_squares[decr]\n                    && curr_squares[decr].type === base_type\n                    && curr_squares[decr].color === base_color; decr -= (w - 1)) {\n                    countBackward.push(decr)\n                }\n                // total:\n                const count = countBackward.length + countForward.length + 1\n                if (count >= 5) {\n                    resolved = [i].concat(countForward, countBackward)\n                }\n            }\n        })\n        return resolved\n    }\n\n    renderSquare(idx) {\n        return <Square key={idx}\n            item={this.state.squares[idx]}\n            onClick={() => this.onSquareClicked(idx)}\n            isActivated={this.state.selected === idx} />;\n    }\n\n    renderRows() {\n        let content = [];\n        for (let i = 0; i < this.state.squares.length; i++) {\n            content.push(this.renderSquare(i));\n        }\n        return content\n    }\n\n    render() {\n        return (\n            <div className='game-board'>\n                {this.renderRows()}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\nexport default class Score extends React.Component {\n\n    render() {\n        return (\n            <span>{this.props.score}</span>\n        )\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from './board.js'\nimport Score from './score';\n\nclass Game extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            score: 0\n        }\n        this.increaseScore = this.increaseScore.bind(this)\n    }\n\n    increaseScore(incr) {\n        this.setState({ score: this.state.score + incr })\n    }\n\n    render() {\n        return (\n            <div className=\"game\">\n                <div>\n                    <div className=\"score-board\">\n                        <span>Score: </span>\n                        <Score score={this.state.score} />\n                    </div>\n                    <Board w='9' h='9'  score_incr={this.increaseScore} />\n                </div>\n            </div>\n        );\n    }\n}\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}